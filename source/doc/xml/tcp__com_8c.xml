<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.13.2" xml:lang="es">
  <compounddef id="tcp__com_8c" kind="file" language="C++">
    <compoundname>tcp_com.c</compoundname>
    <includes refid="tcp__com_8h" local="yes">tcp_com.h</includes>
    <incdepgraph>
      <node id="7">
        <label>platform.h</label>
        <link refid="platform_8h_source"/>
      </node>
      <node id="8">
        <label>platform_config.h</label>
        <link refid="platform__config_8h_source"/>
      </node>
      <node id="1">
        <label>base_code/MB40ch_wUART/src/tcp_com.c</label>
        <link refid="tcp__com_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>tcp_com.h</label>
        <link refid="tcp__com_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>lwip/tcp.h</label>
      </node>
      <node id="6">
        <label>netif/xadapter.h</label>
      </node>
      <node id="5">
        <label>string.h</label>
      </node>
      <node id="4">
        <label>xil_cache.h</label>
      </node>
      <node id="9">
        <label>xil_printf.h</label>
      </node>
    </incdepgraph>
    <sectiondef kind="define">
      <memberdef kind="define" id="tcp__com_8c_1a689d5b27c26c3219e2734cf083020c32" prot="public" static="no">
        <name>dcorr</name>
        <initializer>256426847</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="10" column="9" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="10" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="tcp__com_8c_1a9ed6a247bc316da9276bbc62748fbc54" prot="public" static="no">
        <name>kaliv</name>
        <initializer>264652860</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="11" column="9" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="11" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="tcp__com_8c_1a0c69e634bdcf9eb82783f548b3f9e187" prot="public" static="no">
        <name>recok</name>
        <initializer>273088441</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="12" column="9" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="12" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="tcp__com_8c_1afd51c6ba698aaa1a0d7989a5818a6c3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void rand_data</definition>
        <argsstring>()</argsstring>
        <name>rand_data</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>rand_data</para>
<para>Genera datos aleatorios para simular la adquisición de datos de hardware. Se reserva memoria para un arreglo de 1017*9 enteros y se asignan valores aleatorios en el rango [1950, 2050]. Esta función se utiliza para poblar la variable global &quot;datos_PL&quot;, la cual se emplea posteriormente en el empaquetado de datos.</para>
<para>No recibe parámetros.</para>
<para>Ejemplo: // Inicializa la tabla de datos aleatorios rand_data(); </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="28" column="6" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="28" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1ae6eebda0957833b626bcecacfcf9b7fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void packer</definition>
        <argsstring>()</argsstring>
        <name>packer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>packer</para>
<para>Empaqueta los datos almacenados en la matriz global &quot;datos_PL&quot; en un único buffer formateado. La función recorre &quot;datos_PL&quot; en bloques de 9 valores (representando los datos de cada línea) y crea una cadena con formato utilizando separadores de tabulación y un salto de línea al final de cada fila. Este buffer (almacenado en la variable global &quot;buffer&quot;) es el que se utilizará para enviar los datos mediante TCP.</para>
<para>No recibe parámetros.</para>
<para>Ejemplo: // Empaqueta los datos en el buffer antes de enviarlos por TCP packer();</para>
<para>Diagrama de flujo (simplificado): <verbatim>datos_PL --&gt; Iteración por bloques de 9 elementos
             └─&gt; Formatea la línea y concatena en &quot;buffer&quot;
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="64" column="6" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="64" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1af3eae4c3b427dfe050e36557db53650f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned long</type>
        <definition>unsigned long hash</definition>
        <argsstring>(unsigned char *str)</argsstring>
        <name>hash</name>
        <param>
          <type>unsigned char *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>hash</para>
<para>Calcula un valor hash para una cadena de caracteres usando el algoritmo djb2.</para>
<sect1 id="tcp__com_8c_1autotoc_md12_1s1"><sect2 id="tcp__com_8c_1autotoc_md12">
<title>Parameters</title><para>str : unsigned char* La cadena para la que se calculará el hash.</para>
</sect2></sect1>
<sect1 id="tcp__com_8c_1autotoc_md13_1s1"><sect2 id="tcp__com_8c_1autotoc_md13">
<title>Returns</title><para>unsigned long El valor hash calculado.</para>
<para>Ejemplo: unsigned long valor = hash((unsigned char*)&quot;Ejemplo&quot;); </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="112" column="15" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="112" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1acf75bb5ef6105dd155ddc36f84a71606" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void print_ip</definition>
        <argsstring>(char *msg, ip_addr_t *ip)</argsstring>
        <name>print_ip</name>
        <param>
          <type>char *</type>
          <declname>msg</declname>
        </param>
        <param>
          <type>ip_addr_t *</type>
          <declname>ip</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>print_ip</para>
<para>Imprime una dirección IP en la salida utilizando xil_printf, precedida de un mensaje.</para>
<sect1 id="tcp__com_8c_1autotoc_md14_1s1"><sect2 id="tcp__com_8c_1autotoc_md14">
<title>Parameters</title><para>msg : char* Mensaje descriptivo a imprimir. ip : ip_addr_t* Puntero a la estructura que contiene la dirección IP.</para>
<para>Ejemplo: print_ip(&quot;Dirección IP de la placa: &quot;, &amp;ipaddr); </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="141" column="6" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="141" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1a267907eb6db3b11649fd717d308572fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void print_ip_settings</definition>
        <argsstring>(ip_addr_t *ip, ip_addr_t *mask, ip_addr_t *gw)</argsstring>
        <name>print_ip_settings</name>
        <param>
          <type>ip_addr_t *</type>
          <declname>ip</declname>
        </param>
        <param>
          <type>ip_addr_t *</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>ip_addr_t *</type>
          <declname>gw</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>print_ip_settings</para>
<para>Imprime la configuración completa de la red: IP, máscara de subred y gateway.</para>
<sect1 id="tcp__com_8c_1autotoc_md15_1s1"><sect2 id="tcp__com_8c_1autotoc_md15">
<title>Parameters</title><para>ip : ip_addr_t* Dirección IP de la placa. mask : ip_addr_t* Máscara de subred. gw : ip_addr_t* Gateway.</para>
<para>Ejemplo: print_ip_settings(&amp;ipaddr, &amp;netmask, &amp;gateway); </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="165" column="6" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="165" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1a2beb53f1e92fbfa2217fa39c983d8202" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int transfer_data_bkup</definition>
        <argsstring>(unsigned char *buffer)</argsstring>
        <name>transfer_data_bkup</name>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>transfer_data_bkup</para>
<para>Versión alternativa para transferir datos vía TCP. Crea una estructura pbuf para encapsular el contenido del buffer y lo envía de una sola vez.</para>
<para>NOTA: Esta versión se mantiene como respaldo y es menos elaborada que transfer_data.</para>
<sect1 id="tcp__com_8c_1autotoc_md16_1s1"><sect2 id="tcp__com_8c_1autotoc_md16">
<title>Parameters</title><para>buffer : unsigned char* Buffer de datos a enviar.</para>
</sect2></sect1>
<sect1 id="tcp__com_8c_1autotoc_md17_1s1"><sect2 id="tcp__com_8c_1autotoc_md17">
<title>Returns</title><para>int ERR_OK (generalmente 0) si la operación es exitosa.</para>
<para>Ejemplo: int ret = transfer_data_bkup(buffer); </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="195" column="5" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="195" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1a6f76e8c361bc90b5b8b689e0ee7309a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int transfer_data</definition>
        <argsstring>(unsigned char *buffer)</argsstring>
        <name>transfer_data</name>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>transfer_data</para>
<para>Envía el contenido del buffer global a través de la conexión TCP, gestionando el envío en múltiples trozos si el buffer de envío (tcp_sndbuf) es insuficiente. La función divide el buffer en fragmentos y envía cada uno hasta que se transmitan todos los datos. Al finalizar, envía una secuencia de fin (&quot;!#\n&quot;) para indicar la conclusión de la transmisión.</para>
<sect1 id="tcp__com_8h_1autotoc_md18_1s1"><sect2 id="tcp__com_8h_1autotoc_md18">
<title>Parameters</title><para>buffer : unsigned char* Buffer de datos a enviar.</para>
</sect2></sect1>
<sect1 id="tcp__com_8h_1autotoc_md19_1s1"><sect2 id="tcp__com_8h_1autotoc_md19">
<title>Returns</title><para>int 0 si la transmisión se realizó con éxito.</para>
<para>Ejemplo: // Envío de datos empaquetados previamente transfer_data(buffer);</para>
<para>Detalles:<itemizedlist>
<listitem><para>Mientras hayan datos pendientes, se consulta el espacio disponible en tcp_sndbuf.</para>
</listitem><listitem><para>Se utiliza tcp_write para enviar el fragmento actual y tcp_output para forzar el envío inmediato.</para>
</listitem><listitem><para>Si tcp_sndbuf está lleno, se espera (con usleep) antes de reintentar. </para>
</listitem></itemizedlist>
</para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="251" column="5" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="251" bodyend="301"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1a8bff9fa25a621d38c253d35bd0984584" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tcp_server_close</definition>
        <argsstring>(struct tcp_pcb *pcb)</argsstring>
        <name>tcp_server_close</name>
        <param>
          <type>struct tcp_pcb *</type>
          <declname>pcb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>tcp_server_close</para>
<para>Cierra la conexión TCP asociada a &quot;pcb&quot; de forma ordenada. Se deshabilitan callbacks de recepción y errores antes de intentar cerrar la conexión. Si el cierre falla, se aborta la conexión para liberar recursos.</para>
<sect1 id="tcp__com_8h_1autotoc_md20_1s1"><sect2 id="tcp__com_8h_1autotoc_md20">
<title>Parameters</title><para>pcb : struct tcp_pcb* Puntero a la estructura PCB de la conexión TCP.</para>
<para>Ejemplo: tcp_server_close(pcb); </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="319" column="6" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="319" bodyend="332"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1a9804e3442adfd5065e1de662f06c1949" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tcp_server_err</definition>
        <argsstring>(void *arg, err_t err)</argsstring>
        <name>tcp_server_err</name>
        <param>
          <type>void *</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>err_t</type>
          <declname>err</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>tcp_server_err</para>
<para>Función callback que se invoca cuando ocurre un error en la conexión TCP. Se utiliza para limpiar la conexión llamando a tcp_server_close y notifica mediante mensajes de log.</para>
<sect1 id="tcp__com_8h_1autotoc_md21_1s1"><sect2 id="tcp__com_8h_1autotoc_md21">
<title>Parameters</title><para>arg : void* Argumento de callback (no utilizado en este caso). err : err_t Código de error que ha provocado el callback.</para>
<para>Ejemplo: // Esta función se registra como callback de error en tcp_err: tcp_err(pcb, tcp_server_err); </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="352" column="6" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="352" bodyend="360"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1a3720d702a61e4d4cee2a4903373db7d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>err_t</type>
        <definition>err_t accept_callback</definition>
        <argsstring>(void *arg, struct tcp_pcb *newpcb, err_t err)</argsstring>
        <name>accept_callback</name>
        <param>
          <type>void *</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>struct tcp_pcb *</type>
          <declname>newpcb</declname>
        </param>
        <param>
          <type>err_t</type>
          <declname>err</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>accept_callback</para>
<para>Callback que se ejecuta cuando el servidor TCP acepta una nueva conexión. Esta función asigna la nueva conexión al PCB global, configura los callbacks de recepción, envío y error, e incrementa un contador para futuras conexiones. Además, habilita los flags pertinentes (por ejemplo, flag_ready2sent) para indicar que la conexión está establecida.</para>
<sect1 id="tcp__com_8h_1autotoc_md22_1s1"><sect2 id="tcp__com_8h_1autotoc_md22">
<title>Parameters</title><para>arg : void* Argumento de callback (en este caso un entero que indica el ID de la conexión). newpcb : struct tcp_pcb* PCB de la nueva conexión establecida. err : err_t Código de error (se espera ERR_OK en una conexión exitosa).</para>
</sect2></sect1>
<sect1 id="tcp__com_8h_1autotoc_md23_1s1"><sect2 id="tcp__com_8h_1autotoc_md23">
<title>Returns</title><para>err_t ERR_OK si la conexión se aceptó correctamente.</para>
<para>Ejemplo: // Se configura el callback de aceptación en start_application: tcp_accept(pcb, accept_callback);</para>
<para>Diagrama de relaciones: <verbatim>accept_callback --&gt; Asigna PCB global --&gt; (pcb)
                 --&gt; Configura: recv_callback, sent_callback, tcp_server_err
                 --&gt; Habilita flag_ready2sent
</verbatim> </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="395" column="7" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="395" bodyend="422"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1a801824bc66ef5f24d02c9def1d4ece62" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int start_application</definition>
        <argsstring>()</argsstring>
        <name>start_application</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>start_application</para>
<para>Inicializa el servidor TCP creando un nuevo PCB, vinculándolo al puerto definido (6543), y pasando al modo listen. Además, asigna el callback de aceptación (accept_callback) para gestionar conexiones entrantes. Actualiza flags globales para el control de la conexión.</para>
<sect1 id="tcp__com_8h_1autotoc_md24_1s1"><sect2 id="tcp__com_8h_1autotoc_md24">
<title>Returns</title><para>int 0 si el servidor se inició correctamente, o un valor negativo en caso de error.</para>
<para>Ejemplo: if (start_application() != 0) { xil_printf(&quot;Error iniciando la aplicación TCP.\n&quot;); }</para>
<para>Flujo: tcp_new() -&gt; tcp_bind() -&gt; tcp_listen() -&gt; tcp_accept() --&gt; Conexión en espera </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="446" column="5" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="446" bodyend="493"/>
      </memberdef>
      <memberdef kind="function" id="tcp__com_8c_1a0584df6fdfa48022831dec27f863e371" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>tcp_sent_fn</type>
        <definition>tcp_sent_fn sent_callback</definition>
        <argsstring>(void *arg, struct tcp_pcb *tpcb, u16_t len)</argsstring>
        <name>sent_callback</name>
        <param>
          <type>void *</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>struct tcp_pcb *</type>
          <declname>tpcb</declname>
        </param>
        <param>
          <type>u16_t</type>
          <declname>len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>sent_callback</para>
<para>Callback que se invoca cuando se confirma que un paquete de datos fue enviado exitosamente. Esta función restablece el flag flag_ready2sent para permitir el envío de nuevos datos.</para>
<sect1 id="tcp__com_8h_1autotoc_md25_1s1"><sect2 id="tcp__com_8h_1autotoc_md25">
<title>Parameters</title><para>arg : void* Argumento de callback (no utilizado en esta implementación). tpcb : struct tcp_pcb* PCB de la conexión TCP. len : u16_t Longitud del paquete enviado.</para>
</sect2></sect1>
<sect1 id="tcp__com_8h_1autotoc_md26_1s1"><sect2 id="tcp__com_8h_1autotoc_md26">
<title>Returns</title><para>tcp_sent_fn (err_t) ERR_OK, indicando que la operación se realizó correctamente.</para>
<para>Ejemplo: // Se asigna en accept_callback: tcp_sent(pcb, sent_callback); </para>
</sect2></sect1>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="base_code/MB40ch_wUART/src/tcp_com.c" line="519" column="13" bodyfile="base_code/MB40ch_wUART/src/tcp_com.c" bodystart="519" bodyend="526"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>tcp_com.c</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/><sp/>Created<sp/>on:<sp/>01-06-2021</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>Author:<sp/>DAQatlas</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;tcp_com.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="comment">//#include<sp/>&quot;main.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>dcorr<sp/>256426847</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>kaliv<sp/>264652860</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>recok<sp/>273088441</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>rand_data()</highlight></codeline>
<codeline lineno="29"><highlight class="normal">{</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;\nstart_rand_data\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/>datos_PL<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)*1017);</highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(i<sp/>=<sp/>0;i&lt;1017*9;i++)</highlight><highlight class="comment">//9*113<sp/>datos</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>datos_PL[i]<sp/>=<sp/>rand()<sp/>%100<sp/>+1950;</highlight><highlight class="comment">//Numeros<sp/>entre<sp/>1950<sp/>y<sp/>2050<sp/>&quot;&quot;aleatorios&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;\nend_rand_data<sp/>\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal">}</highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>packer()<sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal">{</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;\nstart_packer\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=0<sp/>;</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>line[Char_per_line*N_lines]={</highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">};</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>line2[Char_per_line]={</highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">};<sp/></highlight><highlight class="comment">//mandar<sp/>de<sp/>a<sp/>100<sp/>lineas</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//line2=(char*)malloc(sizeof(char)*321);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>Lines_saves<sp/>=<sp/>N_lines/N_lines;<sp/><sp/>//Entero<sp/>se<sp/>redondea...0.5<sp/>por<sp/>que<sp/>son<sp/>2<sp/>bytes<sp/>por<sp/>char</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\nLineas:<sp/>%d\n&quot;</highlight><highlight class="normal">,<sp/>N_lines);</highlight></codeline>
<codeline lineno="73"><highlight class="normal"></highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(i=0;i&lt;N_lines;i++)</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/>snprintf(line2,Char_per_line,</highlight><highlight class="stringliteral">&quot;%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n&quot;</highlight><highlight class="normal">,datos_PL[9*i],datos_PL[9*i+1],datos_PL[9*i+2],datos_PL[9*i+3]</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,datos_PL[9*i+4],datos_PL[9*i+5],datos_PL[9*i+6],datos_PL[9*i+7],datos_PL[9*i+8]);</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//xil_printf(&quot;Linea<sp/>%d:<sp/>%s\n&quot;,i,line2);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>strcat(line,line2);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//xil_printf(&quot;Linea<sp/>%d:<sp/>%s\n&quot;,i,line);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/>strncpy(buffer,line,N_lines*Char_per_line);</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//xil_printf(&quot;\nLines\n%s\n\nBuffer:\n%s\n\n&quot;,line,buffer);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;%s\n&quot;,line);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//strcpy(buffer,*line);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//free(line);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//free(line2);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;\nend_packer\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="90"><highlight class="normal">}</highlight></codeline>
<codeline lineno="91"><highlight class="normal"></highlight></codeline>
<codeline lineno="92"><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>hash(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*str)</highlight></codeline>
<codeline lineno="113"><highlight class="normal">{</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>hash<sp/>=<sp/>5381;</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c;</highlight></codeline>
<codeline lineno="116"><highlight class="normal"></highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(c<sp/>=<sp/>*str++)</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hash<sp/>=<sp/>((hash<sp/>&lt;&lt;<sp/>5)<sp/>+<sp/>hash)<sp/>+<sp/>c;<sp/></highlight><highlight class="comment">/*<sp/>hash<sp/>*<sp/>33<sp/>+<sp/>c<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>hash;</highlight></codeline>
<codeline lineno="121"><highlight class="normal">}</highlight></codeline>
<codeline lineno="122"><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight></codeline>
<codeline lineno="125"><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_ip(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg,<sp/>ip_addr_t<sp/>*ip)</highlight></codeline>
<codeline lineno="142"><highlight class="normal">{</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/>print(msg);</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;%d.%d.%d.%d\n\r&quot;</highlight><highlight class="normal">,<sp/>ip4_addr1(ip),<sp/>ip4_addr2(ip),</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ip4_addr3(ip),<sp/>ip4_addr4(ip));</highlight></codeline>
<codeline lineno="146"><highlight class="normal">}</highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_ip_settings(ip_addr_t<sp/>*ip,<sp/>ip_addr_t<sp/>*mask,<sp/>ip_addr_t<sp/>*gw)</highlight></codeline>
<codeline lineno="166"><highlight class="normal">{</highlight></codeline>
<codeline lineno="167"><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/>print_ip(</highlight><highlight class="stringliteral">&quot;Board<sp/>IP:<sp/>&quot;</highlight><highlight class="normal">,<sp/>ip);</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/>print_ip(</highlight><highlight class="stringliteral">&quot;Netmask<sp/>:<sp/>&quot;</highlight><highlight class="normal">,<sp/>mask);</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>print_ip(</highlight><highlight class="stringliteral">&quot;Gateway<sp/>:<sp/>&quot;</highlight><highlight class="normal">,<sp/>gw);</highlight></codeline>
<codeline lineno="171"><highlight class="normal">}</highlight></codeline>
<codeline lineno="172"><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"></highlight></codeline>
<codeline lineno="195"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>transfer_data_bkup(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*buffer)</highlight></codeline>
<codeline lineno="196"><highlight class="normal">{</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err_t<sp/>err;</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">pbuf<sp/>*<sp/>p;</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>pbuf_alloc(PBUF_TRANSPORT,PBUF_LENGTH,PBUF_RAM);</highlight></codeline>
<codeline lineno="200"><highlight class="normal"></highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//tcp_arg(tpcb,<sp/>NULL);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tcp_close(pcb);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tcp_recv(pcb,<sp/>NULL);</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ERR_OK;</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;TCP<sp/>Buffer<sp/>to<sp/>be<sp/>sent:&lt;----\n%s\n---&gt;\n&quot;</highlight><highlight class="normal">,buffer);</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;payload<sp/>=<sp/>buffer;</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;len<sp/>=<sp/>(uint16_t)strlen(buffer);</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;tcp_sndbuf:%d;p-&gt;len=%d\n&quot;</highlight><highlight class="normal">,<sp/>tcp_sndbuf(pcb),p-&gt;len);</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tcp_sndbuf(pcb)<sp/>&gt;<sp/>p-&gt;len)</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err<sp/>=<sp/>tcp_write(pcb,p-&gt;payload,p-&gt;len,<sp/>TCP_WRITE_FLAG_COPY);</highlight></codeline>
<codeline lineno="214"><highlight class="normal"></highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(err<sp/>!=<sp/>ERR_OK)</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;error<sp/>write<sp/>%d\n&quot;</highlight><highlight class="normal">,<sp/>err);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pbuf_free(p);</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>usleep(200);</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="221"><highlight class="normal">}</highlight></codeline>
<codeline lineno="222"><highlight class="normal"></highlight></codeline>
<codeline lineno="223"><highlight class="normal"></highlight></codeline>
<codeline lineno="251"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>transfer_data(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*buffer)</highlight></codeline>
<codeline lineno="252"><highlight class="normal">{</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/>u16_t<sp/>total<sp/>=<sp/>(uint16_t)strlen(buffer);</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/>u16_t<sp/>remaining<sp/>=<sp/>total;</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/>u8_t<sp/>*data_ptr<sp/>=<sp/>buffer;</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;TCP<sp/>Buffer<sp/>to<sp/>be<sp/>sent:&lt;----\n%s\n---&gt;\n&quot;</highlight><highlight class="normal">,buffer);</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;tcp_sndbuf<sp/>size/<sp/>buffer<sp/>size<sp/>---<sp/>%d/%d\n&quot;</highlight><highlight class="normal">,<sp/>tcp_sndbuf(pcb),remaining);</highlight></codeline>
<codeline lineno="258"><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(remaining<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>u16_t<sp/>available_space<sp/>=<sp/>tcp_sndbuf(pcb);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>u16_t<sp/>to_send<sp/>=<sp/>LWIP_MIN(remaining,<sp/>available_space);</highlight></codeline>
<codeline lineno="262"><highlight class="normal"></highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err_t<sp/>err<sp/>=<sp/>tcp_write(pcb,<sp/>data_ptr,<sp/>to_send,<sp/>TCP_WRITE_FLAG_COPY);</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(err<sp/>==<sp/>ERR_OK<sp/>&amp;&amp;<sp/>available_space&gt;0)<sp/>{</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tcp_output(pcb);<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>force<sp/>send<sp/>as<sp/>soon<sp/>as<sp/>possible</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remaining<sp/>-=<sp/>to_send;</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_ptr<sp/>+=<sp/>to_send;</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;msg<sp/>sent,<sp/>remaining/total/available<sp/>----<sp/><sp/>%d/%d/%d\n&quot;</highlight><highlight class="normal">,remaining,total,available_space);</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(err<sp/>==<sp/>ERR_MEM)<sp/>{</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>the<sp/>snd<sp/>buff<sp/>is<sp/>full,<sp/>wait<sp/>to<sp/>send</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>usleep(10000);</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(err<sp/>!=<sp/>ERR_OK){</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;Error<sp/>sending,error<sp/>code:<sp/>%d\n&quot;</highlight><highlight class="normal">,err);</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>usleep(100);</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/>usleep(100);</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(data_ptr,<sp/>0,<sp/>strlen(data_ptr));</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/>snprintf(data_ptr,40,</highlight><highlight class="stringliteral">&quot;!#\n&quot;</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//end<sp/>character<sp/>sequence</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/>remaining<sp/>=<sp/>(uint16_t)strlen(data_ptr);</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//sending<sp/>end<sp/>characters<sp/>sequence</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(remaining<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>u16_t<sp/>available_space<sp/>=<sp/>tcp_sndbuf(pcb);</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>u16_t<sp/>to_send<sp/>=<sp/>LWIP_MIN(remaining,<sp/>available_space);</highlight></codeline>
<codeline lineno="286"><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err_t<sp/>err<sp/>=<sp/>tcp_write(pcb,<sp/>data_ptr,<sp/>to_send,<sp/>TCP_WRITE_FLAG_COPY);</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(err<sp/>==<sp/>ERR_OK)<sp/>{</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tcp_output(pcb);<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>force<sp/>send<sp/>as<sp/>soon<sp/>as<sp/>possible</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remaining<sp/>-=<sp/>to_send;</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_ptr<sp/>+=<sp/>to_send;</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(err<sp/>==<sp/>ERR_MEM)<sp/>{</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>the<sp/>snd<sp/>buff<sp/>is<sp/>full,<sp/>wait<sp/>to<sp/>send</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>usleep(10000);</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;Error<sp/>sending,error<sp/>code:<sp/>%d\n&quot;</highlight><highlight class="normal">,err);</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/>usleep(100);</highlight></codeline>
<codeline lineno="301"><highlight class="normal">}</highlight></codeline>
<codeline lineno="302"><highlight class="normal"></highlight></codeline>
<codeline lineno="303"><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>tcp_server_close(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>tcp_pcb<sp/>*pcb)</highlight></codeline>
<codeline lineno="320"><highlight class="normal">{</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/>err_t<sp/>err;</highlight></codeline>
<codeline lineno="322"><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pcb<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tcp_recv(pcb,<sp/>NULL);</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tcp_err(pcb,<sp/>NULL);</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err<sp/>=<sp/>tcp_close(pcb);</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(err<sp/>!=<sp/>ERR_OK)<sp/>{</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Free<sp/>memory<sp/>with<sp/>abort<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tcp_abort(pcb);</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="332"><highlight class="normal">}</highlight></codeline>
<codeline lineno="333"><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"></highlight></codeline>
<codeline lineno="352"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>tcp_server_err(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*arg,<sp/>err_t<sp/>err)</highlight></codeline>
<codeline lineno="353"><highlight class="normal">{</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/>LWIP_UNUSED_ARG(err);</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/>tcp_server_close(pcb);</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/>pcb<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//tcp_conn_report(diff_ms,<sp/>TCP_ABORTED_REMOTE);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;TCP<sp/>connection<sp/>aborted\n\r&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//start_application();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal">}</highlight></codeline>
<codeline lineno="361"><highlight class="normal"></highlight></codeline>
<codeline lineno="362"><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal">err_t<sp/>accept_callback(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*arg,<sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>tcp_pcb<sp/>*newpcb,<sp/>err_t<sp/>err)</highlight></codeline>
<codeline lineno="396"><highlight class="normal">{</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>connection<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;*Conexion<sp/>aceptada\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>set<sp/>the<sp/>receive<sp/>callback<sp/>for<sp/>this<sp/>connection<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/>pcb<sp/>=<sp/>newpcb;</highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>just<sp/>use<sp/>an<sp/>integer<sp/>number<sp/>indicating<sp/>the<sp/>connection<sp/>id<sp/>as<sp/>the</highlight></codeline>
<codeline lineno="404"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>callback<sp/>argument<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/>tcp_arg(pcb,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)(UINTPTR)connection);</highlight></codeline>
<codeline lineno="406"><highlight class="normal"></highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//transfer_data(newpcb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="408"><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>increment<sp/>for<sp/>subsequent<sp/>accepted<sp/>connections<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="411"><highlight class="comment"><sp/><sp/><sp/><sp/>tcp_recv(newpcb,<sp/>recv_callback);</highlight></codeline>
<codeline lineno="412"><highlight class="comment"><sp/><sp/><sp/><sp/>tcp_sent(newpcb,<sp/>(tcp_sent_fn)sent_callback);</highlight></codeline>
<codeline lineno="413"><highlight class="comment"><sp/><sp/><sp/><sp/>tcp_err(newpcb,<sp/>tcp_server_err);</highlight></codeline>
<codeline lineno="414"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/>tcp_recv(pcb,<sp/>recv_callback);</highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/>tcp_sent(pcb,<sp/>(tcp_sent_fn)sent_callback);</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/>tcp_err(pcb,<sp/>tcp_server_err);</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/>flag_accept_conn<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/>connection++;</highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/><sp/><sp/>flag_ready2sent<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ERR_OK;</highlight></codeline>
<codeline lineno="422"><highlight class="normal">}</highlight></codeline>
<codeline lineno="423"><highlight class="normal"></highlight></codeline>
<codeline lineno="424"><highlight class="normal"></highlight></codeline>
<codeline lineno="425"><highlight class="normal"></highlight></codeline>
<codeline lineno="446"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>start_application()</highlight></codeline>
<codeline lineno="447"><highlight class="normal">{</highlight></codeline>
<codeline lineno="448"><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/>err_t<sp/>err;</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>port<sp/>=<sp/>PORT;</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/>flag_ready2sent<sp/>=0;</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/>flag_senddata<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/>flag_accept_conn<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>create<sp/>new<sp/>TCP<sp/>PCB<sp/>structure<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pcb<sp/>=<sp/>tcp_new_ip_type(IPADDR_TYPE_ANY);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/>pcb<sp/>=<sp/>tcp_new();</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!pcb)<sp/>{</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;Error<sp/>creating<sp/>PCB.<sp/>Out<sp/>of<sp/>Memory\n\r&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/>tcp_nagle_disable(pcb);</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//For<sp/>keep<sp/>alive</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pcb-&gt;keep_cnt<sp/>=<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pcb-&gt;keep_intvl<sp/>=<sp/>4;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pcb-&gt;keep_idle<sp/>=<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>bind<sp/>to<sp/>specified<sp/>@port<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/>err<sp/>=<sp/>tcp_bind(pcb,<sp/>IP_ANY_TYPE,<sp/>port);</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(err<sp/>!=<sp/>ERR_OK)<sp/>{</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>bind<sp/>to<sp/>port<sp/>%d:<sp/>err<sp/>=<sp/>%d\n\r&quot;</highlight><highlight class="normal">,<sp/>port,<sp/>err);</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-2;</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="473"><highlight class="normal"></highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>we<sp/>do<sp/>not<sp/>need<sp/>any<sp/>arguments<sp/>to<sp/>callback<sp/>functions<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/>tcp_arg(pcb,<sp/>NULL);</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>listen<sp/>for<sp/>connections<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/>pcb<sp/>=<sp/>tcp_listen(pcb);</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!pcb)<sp/>{</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;Out<sp/>of<sp/>memory<sp/>while<sp/>tcp_listen\n\r&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-3;</highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="482"><highlight class="normal"></highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>specify<sp/>callback<sp/>to<sp/>use<sp/>for<sp/>incoming<sp/>connections<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="484"><highlight class="normal"></highlight></codeline>
<codeline lineno="485"><highlight class="normal"></highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/>tcp_accept(pcb,<sp/>accept_callback);</highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/>xil_printf(</highlight><highlight class="stringliteral">&quot;TCP<sp/>server<sp/>started<sp/>@<sp/>port<sp/>%d\n\r&quot;</highlight><highlight class="normal">,<sp/>port);</highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/>flag_tcp_done=1;</highlight></codeline>
<codeline lineno="489"><highlight class="normal"></highlight></codeline>
<codeline lineno="490"><highlight class="normal"></highlight></codeline>
<codeline lineno="491"><highlight class="normal"></highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="493"><highlight class="normal">}</highlight></codeline>
<codeline lineno="494"><highlight class="normal"></highlight></codeline>
<codeline lineno="519"><highlight class="normal">tcp_sent_fn<sp/>sent_callback(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*arg,<sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>tcp_pcb<sp/>*tpcb,<sp/>u16_t<sp/>len)</highlight></codeline>
<codeline lineno="520"><highlight class="normal">{</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/>flag_ready2sent<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//flag_sentdata<sp/>=<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pcb<sp/>=<sp/>tpcb;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ERR_OK;</highlight></codeline>
<codeline lineno="525"><highlight class="normal"></highlight></codeline>
<codeline lineno="526"><highlight class="normal">}</highlight></codeline>
<codeline lineno="527"><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="base_code/MB40ch_wUART/src/tcp_com.c"/>
  </compounddef>
</doxygen>
